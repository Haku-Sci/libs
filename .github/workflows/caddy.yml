name: Deploy Caddy via SSH with generated Caddyfile
on:
  workflow_call:
    inputs:
      SSH_HOST:
        description: 'Override for SSH_HOST variable'
        required: false
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.ref_name }}
    steps:
      - name: Connect to Tailscale
        uses: tailscale/github-action@v2
        with:
          oauth-client-id: ${{ vars.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci

      - name: Start ssh-agent
        uses: webfactory/ssh-agent@v0.4.1
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add SSH host key
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -p ${{ vars.SSH_PORT }} ${{ inputs.SSH_HOST || vars.SSH_HOST }} 2>&1 | tee -a ~/.ssh/known_hosts

      - name: Generate Caddyfile
        run: |
          BRANCH="${{ github.ref_name }}"
          DOMAIN="${{ vars.DOMAIN_NAME }}"

          cat > /tmp/Caddyfile <<BLOCK
          # Auto-generated Caddyfile for branch: $BRANCH

          ${BRANCH}.${DOMAIN} {
              reverse_proxy app_front:3000
              tls internal
          }

          ${BRANCH}-api.${DOMAIN} {
              reverse_proxy app_api:3000
              tls internal
          }

          ${BRANCH}-collab.${DOMAIN} {
              reverse_proxy app_collab:3000
              tls internal
          }
          
          BLOCK

          echo "Generated Caddyfile:"
          cat /tmp/Caddyfile

      - name: Deploy Caddy container via SSH
        run: |
          HOST="${{ inputs.SSH_HOST || vars.SSH_HOST }}"
          PORT="${{ vars.SSH_PORT }}"
          USER="${{ vars.SSH_USER }}"
          TS_AUTHKEY="${{ secrets.TS_OAUTH_SECRET }}"

          scp -P $PORT /tmp/Caddyfile ${USER}@${HOST}:/tmp/Caddyfile

          ssh -p $PORT -o StrictHostKeyChecking=no ${USER}@${HOST} bash -s "$TS_AUTHKEY" << 'EOF'
            TS_AUTHKEY="$1"

            if docker ps -a --format '{{.Names}}' | grep -qw "caddy"; then
              docker rm -f caddy
            fi
            if docker ps -a --format '{{.Names}}' | grep -qw "ts-caddy"; then
              docker rm -f ts-caddy
            fi

            mkdir -p /opt/caddy/config /opt/caddy/data /var/lib/ts-caddy
            mv /tmp/Caddyfile /opt/caddy/config/Caddyfile

            docker network create services 2>/dev/null || true

            # Tailscale sidecar: authenticates via OAuth, creates VPN interface
            docker run -d \
              --name ts-caddy \
              --hostname caddy \
              --cap-add NET_ADMIN \
              --cap-add SYS_MODULE \
              -e TS_AUTHKEY="$TS_AUTHKEY" \
              -e TS_STATE_DIR=/var/lib/tailscale \
              -e TS_USERSPACE=false \
              -e TS_HOSTNAME=caddy \
              -e TS_EXTRA_ARGS="--advertise-tags=tag:ci" \
              -v /var/lib/ts-caddy:/var/lib/tailscale \
              --device /dev/net/tun:/dev/net/tun \
              tailscale/tailscale:latest

            # Connect Tailscale container to services network so Caddy can reach backends
            docker network connect services ts-caddy

            # Wait for Tailscale to be ready
            echo "Waiting for Tailscale to connect..."
            for i in $(seq 1 30); do
              if ! docker inspect -f '{{.State.Running}}' ts-caddy 2>/dev/null | grep -q true; then
                echo "ERROR: ts-caddy container is not running!"
                docker logs ts-caddy
                exit 1
              fi
              if docker exec ts-caddy tailscale status >/dev/null 2>&1; then
                echo "Tailscale is connected!"
                docker exec ts-caddy tailscale ip -4
                break
              fi
              sleep 2
            done

            # Caddy shares Tailscale's network namespace: only reachable via Tailscale IP
            docker run -d \
              --name caddy \
              --network container:ts-caddy \
              -v /opt/caddy/config/Caddyfile:/etc/caddy/Caddyfile:ro \
              -v /opt/caddy/data:/data \
              caddy:2-alpine

            # TCP forwarder: expose database ports via Tailscale
            docker rm -f tcp-forwarder 2>/dev/null || true

            PG=$(docker ps --filter "name=postgresql_" --format '{{.Names}}' | head -1)
            NEO=$(docker ps --filter "name=neo4j_" --format '{{.Names}}' | head -1)

            FWD_CMD=""
            if [ -n "$PG" ]; then
              echo "Forwarding port 5432 -> ${PG}"
              FWD_CMD="socat TCP-LISTEN:5432,fork,reuseaddr TCP:${PG}:5432 & "
            fi
            if [ -n "$NEO" ]; then
              echo "Forwarding ports 7474,7687 -> ${NEO}"
              FWD_CMD="${FWD_CMD}socat TCP-LISTEN:7474,fork,reuseaddr TCP:${NEO}:7474 & socat TCP-LISTEN:7687,fork,reuseaddr TCP:${NEO}:7687 & "
            fi

            if [ -n "$FWD_CMD" ]; then
              docker run -d \
                --name tcp-forwarder \
                --network container:ts-caddy \
                --restart unless-stopped \
                alpine sh -c "apk add --no-cache socat && ${FWD_CMD}wait"
            fi
          EOF
