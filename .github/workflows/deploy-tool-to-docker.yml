name: Set docker tool to run on remote server

on:
  workflow_dispatch:
    inputs:
      target-server:
        description: 'Target SSH server (user@host:port)'
        required: true
        type: string
      tool:
        description: 'Docker tool to run (must match a JSON file in docker-tools/)'
        required: true
        type: choice
        options:
          - caddy
          - neo4j
          - postgresql
      extra_args:
        description: 'Optional additional docker args'
        required: false
        type: string

jobs:
  run-tool:
    name: Run Selected Docker Tool with Extras
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Load tool JSON args
        id: load_json
        run: |
          TOOL="${{ inputs.tool }}"
          FILE="docker-tools/${TOOL}.json"
          if [ ! -f "$FILE" ]; then
            echo "::error::File not found: $FILE"
            exit 1
          fi

          # Retrieve image (always present)
          IMAGE=$(jq -r '.image' "$FILE")

          # Retrieve options array or empty
          OPTIONS=$(jq -r '.options // [] | .[]' "$FILE" | paste -sd ' ' -)

          # Retrieve ports mapping or empty
          PORTS=$(jq -r '.ports // {} | to_entries[] | "-p \(.key):\(.value)"' "$FILE" | paste -sd ' ' -)

          # Retrieve env or empty, wrapping each value in single quotes
          ENVS=""
          jq -r '.env // {} | to_entries[] | "\(.key)\u0000\(.value)"' "$FILE" \
            | while IFS=$'\u0000' read -r key value; do
                ENVS+=" --env $key='$value'"
              done

          # Retrieve commands array or empty
          COMMANDS=$(jq -r '.commands // [] | .[]' "$FILE")

          # Combine Docker arguments and trim extra spaces
          DOCKER_ARGS=$(printf "%s %s %s" "$OPTIONS" "$PORTS" "$ENVS" | xargs)

          echo "image=$IMAGE" >> "$GITHUB_OUTPUT"
          echo "docker_args=$DOCKER_ARGS" >> "$GITHUB_OUTPUT"
          echo "commands=$COMMANDS" >> "$GITHUB_OUTPUT"

      - name: Debug show values
        run: |
          echo "Target server: ${{ inputs.target-server }}"
          echo "Tool: ${{ inputs.tool }}"
          echo "Image: ${{ steps.load_json.outputs.image }}"
          echo "Docker args: ${{ steps.load_json.outputs.docker_args }}"
          echo "Commands: ${{ steps.load_json.outputs.commands }}"
          echo "Extra args: ${{ inputs.extra_args }}"

      - name: Start ssh-agent
        uses: webfactory/ssh-agent@v0.4.1
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Deploy via SSH
        run: |
          SERVER="-p ${{ vars.SSH_PORT }} ${{ vars.SSH_USER }}@${{ inputs.target-server }}"
          TOOL="${{ inputs.tool }}"
          IMAGE="${{ steps.load_json.outputs.image }}"
          ARGS="${{ steps.load_json.outputs.docker_args }}"
          EXTRA="${{ inputs.extra_args }}"
          COMMANDS="${{ steps.load_json.outputs.commands }}"

          echo "Connecting to $SERVER..."
          ssh -o StrictHostKeyChecking=no $SERVER \
            "if docker ps -a --format '{{.Names}}' | grep -qw \"$TOOL\"; then \
               docker rm -f \"$TOOL\" 2>/dev/null; \
             fi"

          echo "Running docker run with all args..."
          ssh -o StrictHostKeyChecking=no $SERVER \
            "docker run -d --name \"$TOOL\" $ARGS $EXTRA \"$IMAGE\" $COMMANDS"
